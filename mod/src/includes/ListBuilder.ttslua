require('!/Analytics')
require('!/Deck')
require('!/Shelf')

-- This is the shared execution code for {RED|BLUE}_LIST_BUILDER.

function onLoadShared(
  colorZone,
  listBuilderOptions, 
  listBuilderButtons,
  backButton,
  dataDiskMount
)
  -- Disable direct interactivity.
  self.interactable = false

  -- Objects passed by the actual (non-shared) code.
  _G.colorZone = colorZone
  _G.listBuilderOptions = listBuilderOptions;
  _G.listBuilderButtons = listBuilderButtons;
  _G.backButton = backButton
  _G.dataDiskMount = dataDiskMount

  -- Other globals.
  _G.listBuilder = Global.getTable("listBuilder")

  -- Use deck data.
  _G.Deck = Deck:create()
  _G.Shelf = Shelf:create()
end

-- UI --------------------------------------------------------------------------

function clearAllButtons()
  for _, o in ipairs(listBuilderOptions) do
    o.clearButtons()
  end
  for _, o in ipairs(listBuilderButtons) do
    o.clearButtons()
    o.setColorTint({0, 0, 0})
  end
  backButton.clearButtons()
  backButton.setColorTint({0, 0,0 })
end

function mainMenu()
  clearAllButtons()
  
  createOptionButton(1, listBuilderOptions[1], listBuilderButtons[1], "chooseArmy", "Create Army", "Create a custom army", {0,0.913,1})
  createOptionButton(2, listBuilderOptions[2], listBuilderButtons[2], "loadArmy", "Load Army", "Load army from Data Disk", {0,0.913,1})
  createOptionButton(3, listBuilderOptions[3], listBuilderButtons[3], "clearZone", "Clear Cards", "Clears current cards", {0,0.913,1})
  createOptionButton(4, listBuilderOptions[4], listBuilderButtons[4], "autoTint", "Auto Tint", "Apply automatic base tinting to yet-to-be-deployed units", {0,0.913,1})
end

function chooseArmy()
  ga_view("list_builder/" .. colorZone .. "/createArmy")
  clearAllButtons()

  changeBackButton("mainMenu", "Go back to Main Menu")
  for i, faction in ipairs(Deck:getFactions()) do
    local name = faction:lower():gsub("^%l", string.upper)
    createOptionButton(
      i,
      listBuilderOptions[i],
      listBuilderButtons[i],
      function()
        ga_view("Game", "createArmy", name)
        Global.setVar(colorZone.."SelectedArmyFaction", faction)
        respawnZone()
        Wait.frames(createArmyMenu)
      end,
      name,
      "Create a " .. name .. " army",
      {0,0.913,1}
    )
  end
end

function createArmyMenu()
  clearAllButtons()

  changeBackButton("chooseArmy", "Go back to Faction Selection")
  createOptionButton(1, listBuilderOptions[1], listBuilderButtons[1], "finishArmy", "Spawn Minis", "Finished creating army", {1,0,0})
  createOptionButton(2, listBuilderOptions[2], listBuilderButtons[2], "saveArmy", "Save Army", "Save army to Data Disk", {0,0.913,1})
  createOptionButton(3, listBuilderOptions[3], listBuilderButtons[3], "respawnZone", "Reset Army", "Reset Army Creation", {0,0.913,1})

  local scenario = deckBuilderObj.getVar("selectedScenario"):gsub("^%l", string.upper)
  createOptionButton(4, listBuilderOptions[4], listBuilderButtons[4], "switchBattleDeck", scenario .. " Battle Deck", "Change Battlefield Deck", {0,0.913,1}, "â†’")
end

function switchBattleDeck()
  local current   = deckBuilderObj.getVar("selectedScenario")
  local scenarios = Deck:getBattleCardScenarios()
  local index     = 0
  for i, name in ipairs(scenarios) do
    if name:lower() == current:lower() then
      index = i
      break
    end
  end
  index = index + 1
  if index > #scenarios then
    index = 1
  end
  current = scenarios[index]
  deckBuilderObj.call("switchBattleDeck", {name = current})
  createArmyMenu()
end

function loadArmyMenu()
  ga_view("list_builder/" .. colorZone .. "/loadArmy")
  clearAllButtons()

  changeBackButton("mainMenu", "Go back to Main Menu")
  createOptionButton(1, listBuilderOptions[1], listBuilderButtons[1], "dud", "Insert Data Disk", "Insert Data Disk into Slot Above", {0,0,0})
  createOptionButton(2, listBuilderOptions[2], listBuilderButtons[2], "loadArmy", "Load Army", "Load army from Data Disk", {0,0.913,1})
end

function respawnZone()
  clearZone()
  spawnTemplates()
end

function finishArmy()
  saveArmy()
  clearZone()
  Wait.time(function()
    loadArmy()
    mainMenu()
  end, 0.5)
end

function autoTint()
  local colorMap
  if colorZone == "red" then
    colorMap = {
      {245, 34, 45},
      {255, 169, 64},
      {255, 236, 61},
      {130, 0, 20},
      {135, 56, 0},
      {135, 104, 0},
    }
  else
    colorMap = {
      {64, 169, 255},
      {54, 207, 201},
      {146, 84, 222},
      {0, 58, 140},
      {0, 71, 79},
      {34, 7, 94},
    }
  end
  for i, color in pairs(colorMap) do
    colorMap[i] = {
      color[1] / 255,
      color[2] / 255,
      color[3] / 255,
    }
  end
  local rankCount = {}
  for _, obj in pairs(cardZone.getObjects()) do
    if obj.getVar("isAMini") == true then
      local unitData = obj.getTable("unitData")
      local rankType = unitData.commandType
      local colorIndex = rankCount[rankType]
      if colorIndex == nil then
        colorIndex = 0
      end
      colorIndex = colorIndex + 1
      if colorIndex > #colorMap then
        colorIndex = 1
      end
      rankCount[rankType] = colorIndex
      local miniGUIDs = obj.getTable("miniGUIDs")
      for _, miniGuid in pairs(miniGUIDs) do
        local miniObj = getObjectFromGUID(miniGuid)
        miniObj.setColorTint(colorMap[colorIndex])
      end
      local unitIDTokenObject = getObjectFromGUID(obj.getVar("unitIDTokenGUID"))
      unitIDTokenObject.setColorTint(colorMap[colorIndex])
    end
  end
end

function clearZone()
  local zoneObjs = cardZone.getObjects()

  -- Remove all items on the table side (except the table itself).
  for _, obj in pairs(zoneObjs) do
    if obj ~= battlefieldTable then
        destroyObject(obj)
    end
  end

  -- Remove all command tokens on the order token tray.
  local trayZone = getObjectFromGUID(commandTokenTrayData[colorSide].trayZoneGUID)
  local trayZoneObjs = trayZone.getObjects()
  for _, obj in pairs(trayZoneObjs) do
    if obj.getVar("isAToken") == true then
        destroyObject(obj)
    end
  end

  local commandStack = getObjectFromGUID(commandTokenTrayData[colorSide].stack)
  local commandStackObjs = commandStack.getObjects()

  -- And do the same for stacked command tokens in the pool.
  for _, obj in pairs(commandStackObjs) do
    local drawnObj = commandStack.takeObject()
    destroyObject(drawnObj)
  end

  -- And the deck builder, if it is exists.
  if deckBuilderObj then
    destroyObject(deckBuilderObj)
    deckBuilderObj = nil
  end

  -- And whatever the "deck zone" is (TBD).
  for i, obj in pairs(deckZone.getObjects()) do
    if obj ~= deckMount then
        destroyObject(obj)
    end
  end

  -- And the hand zone, now that is separate from the other zones.
  for _, obj in pairs(Player[colorZone].getHandObjects()) do
    destroyObject(obj)
  end
end

function dud() end

function createOptionButton(optionNumber, optionObj, optionButton, optionClickFunction, optionLabel, optionToolTip, tint, secondaryButtonText)

  _G[colorSide.."ListBuilderOptionFunction"..optionNumber] = function()
      local toPlay = optionButton
      if not toPlay then
        toPlay = listBuilderButtons[4]
      end
      toPlay.AssetBundle.playTriggerEffect(0)
      if type(optionClickFunction) == "string" then
        _G[optionClickFunction]()
      else
        optionClickFunction()
      end
  end

  if optionNumber > 4 then
    local offset = optionNumber - 4
    -- Sorry, this is a huge hack until we have a fully XML UI list builder.
    listBuilderOptions[4].createButton({
      click_function = colorSide.."ListBuilderOptionFunction"..optionNumber,
      function_owner = self,
      label = optionLabel,
      position = {-0.35, 0.3, offset},
      scale = {0.5, 0.5, 0.5},
      width = 4200,
      height = 600,
      font_size = 400,
      font_color = {0, 0, 0, 100},
      tooltip = optionToolTip,
    })
    return
  end

  optionObj.createButton({
    click_function = colorSide.."ListBuilderOptionFunction"..optionNumber,
    function_owner = self,
    label = optionLabel,
    position = {-0.35, 0.3, 0},
    scale = {0.5, 0.5, 0.5},
    width = 4200,
    height = 600,
    font_size = 400,
    color = {0.7573, 0.7573, 0.7573, 0.01},
    font_color = {0, 0, 0, 100},
    tooltip = optionToolTip,
  })

  optionButton.createButton({
    click_function = colorSide.."ListBuilderOptionFunction"..optionNumber,
    function_owner = self,
    label = secondaryButtonText or "",
    position = {0, 0.65, 0},
    width = 1400,
    height = 1400,
    font_size = 1100,
    color = {1,1,1,0.01},
    font_color = {0, 0, 0, 100},
    tooltip = optionToolTip,
    alignment = 3,
  })

  optionButton.setColorTint(tint)
end

function changeBackButton(optionClickFunction, optionToolTip)
  _G[colorSide.."ListBuilderBackButtonFunction"] = function()
      backButton.AssetBundle.playTriggerEffect(0)
      if type(optionClickFunction) == "string" then
        _G[optionClickFunction]()
      else
        optionClickFunction()
      end
  end

  backButton.createButton({
      click_function = colorSide.."ListBuilderBackButtonFunction", function_owner = self, label = "BACK", position = {0, 0.65, 0}, scale = {1, 1, 0.7}, width = 1500, height = 2000, font_size = 400, color = {0.7573, 0.7573, 0.7573, 0.01}, font_color = {0, 0, 0, 100}, tooltip = optionToolTip
  })
  backButton.setColorTint({1,0,0})
end

-- CALULATE POINTS -------------------------------------------------------------

function calculatePoints()
  local allCards = cardZone.getObjects()
  -- Intentionally global.
  totalPoints = 0
  for _, card in pairs(allCards) do
      local cardPoint = card.getVar("ptCost")
      if cardPoint then
        totalPoints = totalPoints + cardPoint
      end
  end
  ptCounter.setValue(totalPoints)
end

function onObjectDestroyed()
  calculatePoints()
end

function onObjectLeaveScriptingZone()
  calculatePoints()
end

function onObjectEnterScriptingZone()
  calculatePoints()
end

-- SPAWN UNITS AND TEMPLATES FOR LIST CREATION ---------------------------------
function initializeCommandToken(cData)
  local tokenObj = spawnObject({
    type           = "Custom_Model",
    rotation       = cData.rot,
    position       = cData.pos,
  })
  tokenObj.setCustomObject({
    mesh = "http://cloud-3.steamusercontent.com/ugc/786359883314446513/4DBBAC00ABA5EABE88C2A86C3311C3FB6645FF25/",
    collider = "http://cloud-3.steamusercontent.com/ugc/785234780866339915/85F7E717B9EFBE0396126CA673DF17EAFEC7D451/",
    diffuse = commandTokenData[colorSide][cData.commandType],
    type = 0,
    material = 3
  })
  tokenObj.setName(cData.name)
  -- Set the objects script.
  -- Note this is used instead of "setTable()" because onLoad/onSave is buggy with stuff that stacks.
  local luaScript = string.format(
    "_G.unitData = {" ..
    "  baseSize      = [[%s]],\n" ..
    "  colorSide     = [[%s]],\n" ..
    "  commandType   = [[%s]],\n" ..
    "  fixedArc      = %s,\n" ..
    "  fixedMove     = %s,\n" ..
    "  selectedSpeed = %s,\n" ..
    "  strafeMove    = %s,\n" ..
    "}\n\n",
    cData.baseSize,
    colorSide:lower(),
    cData.commandType,
    tostring(cData.baseSize:lower() ~= "small"),
    tostring(cData.baseSize:lower() ~= "small"),
    tostring(cData.selectedSpeed),
    tostring(cData.baseSize:lower() ~= "small")
  )
  tokenObj.setLuaScript(luaScript .. listBuilder.tokenScript)
end

function spawnUnitCard(faction, name, position, rotation)
  local card = Deck:spawnUnitCard(faction, name)
  ga_event("Game", "spawnUnitCard", card.getName())

  local tPos = simpleTranslatePos(position, 0, 0)
  tPos.y = tPos.y
  card.setRotation({0,rotation.y+180,0})
  card.setPosition(tPos)
  return card
end

function spawnLoadoutBag(upgrades, container)
  for _, upgrade in ipairs(upgrades) do
    spawnUpgradeCard(upgrade, container, container.getRotation())
  end
end

function spawnUpgradeCard(cardName, pTemplatePos, pTemplateRot, upgradeNumber, spawnOffsets, xOffset, zOffset)
  local upgradeCard = Deck:spawnUpgradeCard(cardName)

  ga_event("Game", "spawnUpgradeCard", cardName)
  upgradeCard.setRotation({0,pTemplateRot.y+180,0})

  if upgradeNumber == nil then
    local loadoutBag = pTemplatePos
    loadoutBag.putObject(upgradeCard)
  else
    -- cache offsets
    local unitCardWidth = spawnOffsets["unitCardWidth"]
    local halfUnitCard = unitCardWidth * 0.5
    local cardHeight = spawnOffsets["cardHeight"]
    local cardWidth = spawnOffsets["upgradeCardWidth"]
    local halfCardHeight = cardHeight * 0.5
    local halfCardWidth = cardWidth * 0.5
    local padding = spawnOffsets["padding"]

    -- offset upgrade card
    local xPosOffset = 0
    local zPosOffset = 0

    -- x offset
    if ( upgradeNumber == 1 or upgradeNumber == 4 or upgradeNumber == 7) then
      xPosOffset = (halfUnitCard + padding + halfCardWidth) * -xOffset
    elseif ( upgradeNumber == 2 or upgradeNumber == 5 ) then
      xPosOffset = (-halfUnitCard + halfCardWidth + (padding)) * -xOffset
    elseif ( upgradeNumber == 3 or upgradeNumber == 6 ) then
      xPosOffset = (halfCardWidth + padding) * -xOffset
    end 
    
    -- z offset
    if ( upgradeNumber > 1 and upgradeNumber < 5) then
      zPosOffset = ((cardHeight + padding) * zOffset)
    elseif ( upgradeNumber >= 5 ) then
      zPosOffset = ((cardHeight + padding) * 2 * zOffset)
    end
    local finalPos = simpleTranslatePos(pTemplatePos, xPosOffset, zPosOffset)
    upgradeCard.setPosition(finalPos)
  end
end

function spawnTemplates()
  deckBuilderObj = spawnObject({
      type           = "Custom_Model",
      position       = listBuilder.deckBuilderPos[colorSide],
      rotation       = self.getRotation()
  })
  deckBuilderObj.setCustomObject({
      mesh = listBuilder.deckBuilderMesh,
      collider = listBuilder.deckBuilderMesh,
      diffuse = listBuilder.deckBuilderDiffuse,
      type = 1,
      material = 3
  })

  deckBuilderObj.setPosition(listBuilder.deckBuilderPos[colorSide])
  deckBuilderObj.setRotation(self.getRotation())
  deckBuilderObj.setLock(true)
  local deckBuilderScript = getObjectFromGUID(listBuilder.deckBuilderGUID).getLuaScript()
  local factionScript = (
    "selectedFaction  = \""..Global.getVar(colorZone.."SelectedArmyFaction").."\"\n" ..
    "selectedScenario = \"standard\"\n"
  )
  deckBuilderObj.setLuaScript(factionScript..deckBuilderScript)

  templateObjs = {}
  for i=1,20,1 do
      templateParams = {getObjectFromGUID(listBuilder.modelTemplateGUID)}
      copy(templateParams)
      pastedObj = paste({
          position = listBuilder[colorZone.."TemplatePos"][i]
      })

      templateObjs[i] = pastedObj

      templateObjs[i][1].setLock(true)
      templateObjs[i][1].setPosition({templateObjs[i][1].getPosition().x,1,templateObjs[i][1].getPosition().z})
      templateObjs[i][1].setScale({1,1,1})

      templateObjs[i][1].setVar("colorSide", colorZone)
      templateObjs[i][1].setVar("listBuilderObj", self)
      templateObjs[i][1].setVar("templateIndex", i)
      templateObjs[i][1].setVar("deckBuilderObj", deckBuilderObj)
      templateObjs[i][1].setName("")

      if colorSide == "red" then
          templateObjs[i][1].setRotation({0,0,180})

      else
          templateObjs[i][1].setRotation({0,180,180})
      end
  end
end

function spawnArmy(loadListData, skipDiskVersionCheck)
  if skipDiskVersionCheck or loadListData.savedDiskVersion == 3 then
    -- deal command Cards
    for _ , c in ipairs(loadListData.commandCards) do
        dealCommandCard(c, false)
    end
    for _ , c in ipairs(loadListData.contingencies) do
        dealCommandCard(c, true)
    end

      -- create battlefield deck
      deckHeight = 1
      local scenario = loadListData.battlefieldDeck.scenario or "standard"
      drawBattlefieldCard(loadListData, "objective", scenario)
      drawBattlefieldCard(loadListData, "deployment", scenario)
      drawBattlefieldCard(loadListData, "conditions", scenario)
      Global.setVar(colorSide .. "SelectedScenario", scenario)

      offsetUnitSpawnCount = 0

      -- spawn units
      for n, unit in pairs(loadListData.units) do
        spawnUnit(unit, n, loadListData.armyFaction, #loadListData.units)
      end
  else
      ga_exception("spawnArmyUnsupportedArmyDisk")
      broadcastToAll("Unsupported army disk. The mod has changed, please re-create your army.", {1,1,1})
  end
end

-- TODO: Move this function to a common include
-- Helper function to deeply copy a table, including metatables
function copyTable(obj, seen)
  -- Handle non-tables and previously-seen tables.
  if type(obj) ~= 'table' then return obj end
  if seen and seen[obj] then return seen[obj] end

  -- New table; mark it as seen and copy recursively.
  local s = seen or {}
  local res = {}
  s[obj] = res
  for k, v in pairs(obj) do res[copyTable(k, s)] = copyTable(v, s) end
  return setmetatable(res, getmetatable(obj))
end

function spawnUnit(unit, index, faction, totalUnits)
  -- Without this, the templates start shifting, probably due to mutations :(
  _G.listBuilder = Global.getTable("listBuilder")

  local name = unit.name
  local upgrades = unit.upgrades
  local loadout = unit.loadout
  if name == nil or index == nil or faction == nil or totalUnits == nil then
    -- TODO: Figure out a good way to handle this other than ignoring.
    return
  end
  if upgrades == nil then
    upgrades = {}
  end
  if loadout == nil then
    loadout = {}
  end

  -- Prep unit card spawn locations.
  local templatePos = listBuilder[colorSide.."TemplatePos"][index]
  local adjustedPos = {x = templatePos.x, y = templatePos.y, z = templatePos.z}
  local templateHalfWidth = listBuilder.spawnOffsets["templateHalfWidth"]
  local templateHalfHeight = listBuilder.spawnOffsets["templateHalfHeight"]
  local cardHeight = listBuilder.spawnOffsets["cardHeight"]
  local unitCardWidth = listBuilder.spawnOffsets["unitCardWidth"]
  local padding = listBuilder.spawnOffsets["padding"]
  local xOffset = 1
  local zOffset = 1
  if index > 10 then
    -- TODO: Support unit ID tokens > 10.
    index = index - 10
    adjustedPos = {
      x = adjustedPos.x,
      y = adjustedPos.y,
      z = adjustedPos.z - (templateHalfHeight * 0.3),
    }
  end

  -- Orient offsets based on our facing (i.e. red v blue player).
  if (adjustedPos.z < 0) then 
    xOffset = -1
    zOffset = -1
    padding = padding * -1
    cardHeight = cardHeight * -1
    templateHalfWidth = templateHalfWidth * -1   
    templateHalfHeight = templateHalfHeight * -1
  end
  adjustedPos.x = adjustedPos.x + templateHalfWidth - padding
  adjustedPos.z = adjustedPos.z - templateHalfHeight + cardHeight

  -- Spawn Unit Card and ID Token.
  local unitCardObj = spawnUnitCard(
    faction,
    name,
    adjustedPos,
    self.getRotation()
  )
  local miniData = {
    name            = name,
    colorSide       = colorSide,
    upgrades        = {},
    miniObjs        = {},
    -- Intentionally omitted. We use the name assigned from the spawned model.
    displayName     = nil,
    unitID          = index,
    unitCardObj     = unitCardObj,
    unitIDTokenGUID = spawnUnitIDToken(
      adjustedPos,
      self.getRotation(),
      index
    ),
    leaderIndex     = 1,
  }

  -- Spawn Upgrade Cards.
  local upgradeCount = #upgrades
  for i, upgrade in ipairs(upgrades) do
    spawnUpgradeCard(
      upgrade,
      adjustedPos,
      self.getRotation(),
      i,
      listBuilder.spawnOffsets,
      xOffset,
      zOffset
    )
    table.insert(miniData.upgrades, upgrade)
  end

  -- Spawn Minis.

  -- Determine starting mini location (i.e. the leader).
  local initialZOffset = cardHeight + padding
  if upgradeCount > 1 and upgradeCount < 5 then
    initialZOffset = initialZOffset + (cardHeight + padding)
  elseif upgradeCount > 4 then
    initialZOffset = initialZOffset + (cardHeight + padding) * 2
  end

  local objects = {
    position = adjustedPos,
    rotation = self.getRotation(),
  }
  if #loadout > 0 then
    objects.callback = function(spawnedBag)
      spawnLoadoutBag(loadout, spawnedBag)
    end
  end
  local result = Shelf:spawnUnitModels({
    faction    = faction,
    name       = name,
    upgrades   = upgrades,
    additional = objects,
    callback   = function(model, index, base)   
      local baseRadius = base * 0.5
      local initialXOffset = unitCardWidth * 0.5 - baseRadius 
      local xStart = adjustedPos.x + initialXOffset * xOffset
      local position = {
        x = xStart,
        y = adjustedPos.y,
        z = adjustedPos.z,
      }
      local paddedBase = (base + padding) * 1.5
      local basesPerRow = math.abs(math.floor(templateHalfWidth * 2.0 / paddedBase))
      local newIndex = index
      local totalZOffset = initialZOffset
      if index > basesPerRow then
        totalZOffset = initialZOffset + (paddedBase * zOffset)
        newIndex = index - basesPerRow
      end

      local baseOffset = base + (padding * xOffset)
      local totalXOffset = (baseOffset * (newIndex - 1))
      local xDir = xOffset * -1
      if adjustedPos.z < 0 then
        totalZOffset = totalZOffset * -1
      end
      
      model.setPosition(
        simpleTranslatePos(
          position,
          totalXOffset * xDir,
          totalZOffset * zOffset
        )
      )
      local templateRot = self.getRotation()
      local rotation = {templateRot.x, templateRot.y + 180, templateRot.z}
      model.setRotation(rotation)
      model.setColorTint(gameData.getTable("battlefieldTint"))
      table.insert(miniData.miniObjs, {
        obj    = model,
        name   = model.getName(),
        leader = index == miniData.leaderIndex,
      })
    end
  })

  -- TODO: Remove remapping.
  local remap = {
    ["Empire"]     = "imperial",
  }
  if remap[faction] ~= nil then
    faction = remap[faction]
  end
  local known = {imperial = 1, rebel = 1, separatist = 1, republic = 1}
  if not known[faction:lower()] then
    -- HACK: Support homebrew factions.
    faction = "imperial"
  end
  local rankAndRemap = result.rank
  if rankAndRemap then
    if rankAndRemap == "Special Forces" then
      rankAndRemap = "specialForces"
    end
    local commandType = faction:lower() .. rankAndRemap:lower():gsub("^%l", string.upper)
    local commandName = colorSide:gsub("^%l", string.upper) .. 
                        " " .. faction:gsub("^%l", string.upper) ..
                        " " .. result.rank:gsub("^%l", string.upper) ..
                        " Command Token"
    miniData.baseSize = result.size
    miniData.commandName = commandName
    miniData.commandType = commandType
    miniData.selectedSpeed = result.speed
    miniData.height = result.height
    initializeMini(miniData)

    local commandTray = getObjectFromGUID(commandTokenTrayData[colorSide][commandType])
    local pos = commandTray.getPosition()
    pos.y = pos.y + 0.5 + (0.2 * index)
    local rot = self.getRotation()
    rot.y = rot.y + 180

    initializeCommandToken({
      name          = commandName,
      commandType   = commandType,
      pos           = pos,
      rot           = rot,
      baseSize      = result.size,
      selectedSpeed = result.speed,
    })
  end
end

function spawnArmyFromDisk()
  local listData = loadDisk.getVar("listData")
  loadArmyFromJSON(listData)
end

function initializeMini(pMiniTable)
  local strColor = pMiniTable.colorSide
  strColor = strColor:gsub("^%l", string.upper)
  
  -- detect leader units
  local leaderInt = pMiniTable.leaderIndex
  
  for i, objEntry in pairs(pMiniTable.miniObjs) do
    -- init mini script
    local selectedMiniScript = ""

    -- SET NAME
    local displayName = pMiniTable.displayName or objEntry.name
    objEntry.obj.setName(strColor.. " "..displayName)
    selectedMiniScript = selectedMiniScript .. "colorSide = '"..pMiniTable.colorSide.."'\nminiName = \""..objEntry.name.."\"\n"

    if i == leaderInt then
      -- DESCRIPTION
      local description = ""

      for p, upgradeName in pairs(pMiniTable.upgrades) do
        description = description .. upgradeName .. "\n"
      end
      objEntry.obj.setDescription(description)

      -- miniGUIDs

      local miniGUIDsScript = "miniGUIDs = {}\n"
      for n, objEntry in pairs(pMiniTable.miniObjs) do
        miniGUIDsScript = miniGUIDsScript .. "miniGUIDs["..n.."] = '" .. objEntry.obj.getGUID() .. "'\n"
      end
      selectedMiniScript = selectedMiniScript .. miniGUIDsScript .. 
        "cardGUID = \"" .. pMiniTable.unitCardObj.getGUID() .. 
        "\"\n unitName = \""..pMiniTable.name:lower() .. 
        "\"\n commandName = \""..pMiniTable.commandName .. 
        "\"\n commandType = \""..pMiniTable.commandType .. 
        "\"\n selectedSpeed = "..pMiniTable.selectedSpeed .. 
        "\n baseSize = \""..pMiniTable.baseSize .. 
        "\"\n unitID = " .. pMiniTable.unitID .. 
        "\n height = " .. pMiniTable.height ..
        "\n unitIDTokenGUID = \"".. pMiniTable.unitIDTokenGUID .. 
        "\"\n" .. listBuilder.modelMiniScript
    else
      objEntry.obj.use_snap_points = false
    end

    -- SET SCRIPT
    objEntry.obj.setLuaScript(selectedMiniScript)
  end
end

function spawnUnitIDToken(idSpawnPos, idSpawnRot, idNumber)
  idSpawnRot.y = idSpawnRot.y +180
  local idToken = unitIDTokenBag.takeObject({
    position       = idSpawnPos,
    rotation       = idSpawnRot,
    smooth         = false
  })
  local idTokenGUID = idToken.getGUID()
  if idNumber ~= 1 then
    idTokenGUID = idToken.setState(idNumber).getGUID()
  end

  return idTokenGUID
end

-- LIST IMPORT / EXPORT --------------------------------------------------------
function loadArmy()
  local diskObjNumber = 0
  diskZone = getObjectFromGUID(listBuilder[colorSide.. "DataDiskZone"])
  diskObjs = diskZone.getObjects()
  diskObjNumber = 0

  for i, obj in pairs(diskObjs) do
      if obj.getVar("listData") then
          loadDisk = obj
          diskObjNumber = i
      end
  end
  if diskObjNumber == 0 then
      loadArmyMenu()
  else
      clearZone()
      --- LOAD COMMAND CARDS
      spawnArmyFromDisk()
  end
end

function loadArmyFromJSON(jsonData)
  clearZone()
  local author = "Unknown"
  local listData = JSON.decode(jsonData)
  author = listData.author
  spawnArmy(listData, true)
  ga_event("Game", "loadArmyFromJSON", author)
end

function getListData()
  if not templateObjs[1][1] then
    return nil
  end
  local battleDeck = deckBuilderObj.getTable("battlefieldCardSelection")
  battleDeck.scenario = deckBuilderObj.getVar("selectedScenario")
  local listData    = {
    author          = "SWLegion TTS Mod",
    points          = totalPoints,
    armyFaction     = Global.getVar(colorZone.."SelectedArmyFaction"),
    units           = {},
    commandCards    = deckBuilderObj.getTable("commandCardSelection"),
    contingencies   = deckBuilderObj.getTable("contingencyCardSelection"),
    battlefieldDeck = battleDeck,
  }
  for i=1,20,1 do
    local text = templateObjs[i][1].call("getListText")
    if text then
      local upgrades = {}
      for _, entry in ipairs(text.upgrades) do
        table.insert(upgrades, entry)
      end
      table.insert(listData.units, {
        name     = text.name,
        upgrades = upgrades,
      })
    end
  end
  return listData
end

function saveArmy()
  local success, exception = pcall(saveArmyImpl)
  if success then
    ga_event("Game", "saveArmy")
  else
    ga_exception("saveArmy:" .. tostring(exception))
  end
end

function saveArmyImpl()
  local listData = getListData()
  if not listData then
    return
  end
  local luaString = "function onload() listData = [[" .. JSON.encode(listData) .. "]] end"
  local position = translatePos(dataDiskMount.getPosition(),dataDiskMount.getRotation(),0.03,90)
  position.y = position.y + 1
  local dataDisk = getObjectFromGUID(listBuilder.dataDisk.guid).clone({
    position     = position,
    scale        = {1, 1, 1},
    snap_to_grid = false,
  })
  dataDisk.setRotation(self.getRotation())
  dataDisk.setName("(RENAME ME!) Army Data Disk [" .. totalPoints .. " Points]")
  dataDisk.setLuaScript(luaString)
  dataDisk.setLock(false)
end

function toggleListImporterUI()
  local uiStatus = self.UI.getAttribute('listImporterUI', 'active')
  local newStatus = true
  if uiStatus == 'True' then
    newStatus = false
  end
  self.UI.setAttribute('listImporterUI', 'active', newStatus)
end

function importFromText(nothing, text)
  loadArmyFromJSON(text)
end

function dealCommandCard(selectionCard, isContingency)
  local card = Deck:spawnCommandCard(selectionCard, isContingency)
  if isContingency then
    card.highlightOn({0, 1, 1})
  end
  card.setRotation(listBuilder.handPos[colorSide].rot)
  card.setPosition(listBuilder.handPos[colorSide].pos)
end

function drawBattlefieldCard(data, cardType, battleDeckScenario)
  for _, entry in pairs(data.battlefieldDeck[cardType]) do
    local card = Deck:spawnBattleCard(cardType, entry, battleDeckScenario)
    local deckMountPos = deckMount.getPosition()
    deckMountPos.y = deckMountPos.y + 0.23 + (deckHeight * 0.1)
    deckHeight = deckHeight + 1
    card.setPosition(deckMountPos)

    local deckRot = deckMount.getRotation()
    deckRot.z = 180
    card.setRotation(deckRot)
  end
end
